Après s'être initialisé, chaque footbot éxécute a chaque pas une séquence d'opérations communes à tous les états possibles, suivie d'une séquence s'opérations propre à l'état courant.
\begin{lstlisting}[caption=Fonction step]
function step()
  local obstacleProximity, obstacleDirection, onSource,
        foundSource, backHome, gotSource,
        emerProx, emerDir
  obstacleProximity, obstacleDirection, onSource,
  foundSource, backHome, gotSource,
  emerProx, emerDir = doCommon()
  if emerProx>0 then
    emergencyAvoidance(emerProx, emerDir)
  elseif explore then
    doExplore(obstacleProximity, obstacleDirection,
              foundSource, gotSource)
  else
    doMine(obstacleProximity, obstacleDirection,
           onSource, backHome, foundSource)
  end
end
\end{lstlisting}

\section{Opérations Communes}

Les opérations communes à tous les états sont
\begin{itemize}
  \item L'écoute des capteurs <<vitaux>> c'est-à-dire qu'ils peuvent complètement écraser l'état courant: capteur de proximité (déclenche l'évitement d'urgence) et batterie (force le footbot à rentrer au nid)
  \item L'écoute des autres capteurs qui par essence doivent toujours être consultés: capteur de position, de couleur du sol (permet au footbot d'enregistrer des nouvelles sources à tout moment) et communication entre robots (idem).
  \item Lecture du capteur \emph{distance scanner (short range)} parce qu'il est utilisé en pratique quel que soit l'état du robot.
\end{itemize}

A part pour l'évitement d'urgence, toutes les décisions sont donc uniquement prises par les fonctions \emph{doMine} et \emph{doExplore}. La fonction \emph{doCommon} se contente de leur envoyer des signaux sous la forme des diverses variables renvoyées \emph{onSource, backHome,\ldots}.

L'implémentation détaillée de la fonction doCommon est donnée dans l'annexe \ref{appsec:doCommon}. L'évitement d'urgence est celui présenté dans la section \ref{sec:emerAvoid}, tandis que pour retourner le plus rapidement possible au nid, le footbot utilise simplement le déplacement présenté au chapitre \ref{chap:move} avec pour goal le centre du nid.

\section{Exploration\label{sec:explore}}

Tous les robots sont initialisés dans l'état \emph{explore}. Dans cet état, ils se déplacent selon une méthode d'exploration donnée jusqu'à recevoir le signal \emph{foundSource} ou \emph{gotSource}. Le premier signal signifie que le footbot a lui-même trouvé une nouvelle source, tandis que le second signal indique qu'une nouvelle source lui a été transmise. C'est la fonction \emph{doCommon} qui s'assure qu'une source potentielle est effectivement originale et la stocke alors dans la liste des sources connues. Cette liste est partagée avec les autres robots (voir section \ref{sec:commu}) et utilisée lorsque le robot est dans l'état \emph{exploite}.

Dans le cas où le robot a trouvé une source, il passe directement dans l'état exploite. Par contre, dans le cas où le robot reçu une nouvelle source, il décide aléatoirement s'il continue à explorer ou s'il se met à exploiter la ou les ressources qu'il connaît. La communication entre robot étant relativement efficace, ceci permet d'éviter que tous les robots se contentent d'une unique source dès qu'un seul individu en a fait la découverte. Une amélioration possible serait de permettre au robot de passer de l'état \emph{explore} à l'état \emph{exploite} même en l'absence de découverte originale s'il estime avoir déjà passé trop de temps à explorer.

Le parcours d'exploration pris par le robot est une composante importante et complexe de l'efficacité de la phase d'exploration. Malheureusement, par manque de temps, nous avons dû nous limiter à un simple modèle de diffusion: les robots se déplacent en ligne droite et rebondissent sur tous les obstacles qu'ils rencontrent à la manière de simples particules. Ceci permet d'assurer que les robots migrent des zones les plus concentrées en footbots vers les zones les moins concentrées et que, plus globalement, les robots occupent tout l'espace disponible.

Ce modèle est assez satisfaisant en théorie et en pratique mais n'est pas tout à fait adapté pour plusieurs raisons. Tout d'abord, la gestion de l'autonomie entraîne bien évidemment des retours fréquents des robots vers le nid, ce qui annule en partie l'effet désiré d'homogénéiser la concentration de robots. Ceci devrait être mieux pris en compte. D'autre part, ce modèle permet d'éviter relativement bien l'exploration d'une même zone par un nombre élevé de robots, mais ne permet pas de réellement privilégier d'éventuelles <<zones d'ombres>> qui n'ont encore jamais été explorées. Cependant, le principal facteur limitant semble bien être la portée extrèmement limitée des capteurs de couleur de sol.

L'implémentation du modèle de diffusion est détaillée en annexe \ref{appsec:gasLike}

\section{Exploitation}

Une fois passé dans l'état \emph{exploite}, le footbot fait simplement des allers-retours entre une des ressources connues et le nid en suivant le modèle de déplacement présenté au chapitre \ref{chap:move}. Les opérations communes ont toujours lieu et le footbot continue donc à communiquer avec les autres robots et à lire la couleur du sol. Il reste donc à traiter du choix de la source à exploiter.

Il est possible d'améliorer l'efficacité de l'exploitation en incitant les robots à exploiter les sources fournissant le meilleur rendement. Une possibilité est d'associer un score de qualité à chaque source connue et d'utiliser l'algorithme suivant:

\begin{algorithm}
\caption{Mise en place d'un score de qualité des sources}
\begin{algorithmic}
  \REQUIRE List of available ressources with their quality score
  \LOOP
    \STATE Pick ressource to mine while taking into account their quality score
    \STATE Go to ressource
    \STATE Update ressource quality score
    \STATE Go to nest
  \ENDLOOP
\end{algorithmic}
\end{algorithm}

Il est en fait plus sensé de mettre à jour l'indice de qualité non pas après un aller, mais après un aller-retour. Cependant, ceci aurait été plus difficile à mettre en pratique dans notre cas, et nous avons donc choisi la solution présentée ci-dessus. Pour réévaluer le score d'une source, le pourcentage de batterie restant à ce moment est utilisé, ce qui indique directement le temps mis par le robot pour atteindre la source. Le nouveau score de qualité est donné par
\[newScore(battery, oldScore)=
  \begin{cases}
      oldScore+(1-oldScore) \times \frac{battery}{100} & \text{si }battery > \beta\\
      oldScore-oldScore \times \frac{100-battery}{100} & \text{si } battery \leq \beta\\
  \end{cases}
\]

Où $0<\beta<100$ indique le niveau minimum de batterie à l'arrivée pour qu'une source soit considérée comme rentable. Ceci permet une bonne convergence tout en gardant l'indice de qualité dans l'intervalle $[0,1]$.

L'implémentation détaillée de l'évaluation et du choix des ressources est présentée dans l'annexe \ref{appsec:evalSource}.

\section{Communication\label{sec:commu}}

Vu la structure en boucle demandée par ARGoS, et grâce au pas d'éxécution assez court, les footbots peuvent entièrement partager leur connaissance des ressources sans que la limite de dix Bytes imposée par le système \emph{range and bearing} ne pose problème.

\begin{algorithm}
  \caption{Partage total de la connaissance des ressources}
  \begin{algorithmic}
  \REQUIRE Known ressources list
  \ENSURE Total sharing of the ressource knowledge
  \LOOP
  \STATE broadcast a different source
  \ENDLOOP
  \end{algorithmic}
\end{algorithm}

Dans notre projet, les ressources étant stockées sous forme de liste, les footbots diffusent à chaque pas la i\ieme{} source dans la liste où i est le numéro du pas courant modulo la longueur de la liste des ressources connues.

Une source étant représentée par un couple de nombre à virgule flottante compris entre -500 et 500, la conversion suivante est utilisée pour transmettre l'information:

\vspace{1em}
\makebox[\textwidth][c]{%
\noindent\begin{tabular}{ |c|c|c|c|c|c|c| }
\hline
Byte 1 & Byte 2 & Byte 3 & Byte 4 & Byte 5 & Byte 6 & Byte 7 \\ \hline
\multirow{3}{*}{type message} & \multirow{2}{*}{Signe x} & \multirow{2}{*}{Signe y} & Centaines x & Centaines y & Reste x & Reste y \\ \cline{4-7}
&&&$\left\lfloor \frac{\lvert x \rvert}{100} \right\rfloor$ & $\left\lfloor \frac{\lvert y \rvert}{100} \right\rfloor$
& ${\scriptsize \mathrm{round}}(\lvert x \rvert \bmod 100)$ & ${\scriptsize \mathrm{round}}(\lvert x \rvert \bmod 100)$ \\
\cline{2-7}
&\multicolumn{6}{ |c| }{coordonnées} \\
\hline
\end{tabular}
}

Le premier Byte indique comment décoder et interpréter le reste du message. La table ci-dessus n'est donc valide que pour les messages dont les 6 Bytes après le type sont alloués à une position dans l'arène. Dans notre projet, les footbots ne s'échangent que des messages de type 1: 6 Bytes indiquant les coordonnées d'une nouvelle source.

\section{Gestion de l'autonomie}
Une condition sur l'autonomie des robots a été imposée: l'autonomie est fixée dans le temps, ce qui signifie que leur batterie se décharge de manière constante à chaque pas d'ARGoS. Une valeur chiffrée n'a pas été imposée, mais les robots doivent juste être capables d'effectuer un aller-retour vers un point le plus éloigné de leur nid de départ à leur vitesse de régime. Une fois la batterie écoulée, le robot est rendu incapable de se déplacer mais pourra peut-être être dépanné par un autre membre de l'essaim dans le futur.

Puisque pour le moment le seul but d'un robot est d'exploiter une ressource, celui-ci peut avorter un aller retour dès qu'il estime qu'il n'est plus capable d'atteindre son but et de revenir ensuite à son nid.

\begin{algorithm}
\caption{Gestion de l'autonomie}
\label{algo:batterie}
\begin{algorithmic}[1]
  \REQUIRE \(0 \leq battery \leq 100 :=\) the battery left of the robot
  \ENSURE footbot tries to get back to nest when current goal judged not safely reachable
  \WHILE{goal not reached}
    \STATE update footbot position and battery
    \STATE \(cost \leftarrow evaluate\;cost(position,\;goal,\;[battery])\) \COMMENT{The cost of what is left to do}
    \IF{\(cost > battery\)}
      \STATE \(goal \leftarrow nest\) \COMMENT{Get back to the nest. If the footbot is already on its way back, this doesn't do anything. Appropriate to try to get to the nest when you know you don't have enough to get there?}
    \ENDIF
  \ENDWHILE
\end{algorithmic}
\end{algorithm}
Où evaluate cost(position, goal, [battery]) est la fonction qui évalue l'énergie nécessaire à l'accomplissement du reste du trajet. On peut par exemple utiliser la distance à vol d'oiseau restante à parcourir accompagnée d'un facteur de sécurité, ou alors utiliser une approche heuristique utilisant le rapport entre la batterie utilisée jusqu'au step courant et le déplacement net parcouru vers le but.

En vue de la prochaine étape (la non omniscience des robots), le choix d'implémentation de la batterie autorise des sacrifices, c'est à dire, si un robot, étant à une position, estime devoir aller à une autre position et si sa batterie le lui permet, il ira à cette nouvelle position, sans toutefois vérifier qu'en y allant il pourra rentrer à la base recharger sa batterie. Ce choix favorise l'exploration de l'arène en mettant en avant la réussite de l'ensemble du groupe et non la réussite personnelle, pouvant être interprété comme la recharge de la batterie. Cependant des modifications doivent encore être apportées car nous ne pouvons nous permettre de sacrifier l'ensemble des robots, faute de quoi l'objectif ne sera pas atteint.

\begin{subappendices}
  \appsec{Implémentation des opérations communes en Lua\label{appsec:doCommon}}
  \subsection{Appels faits par \emph{doCommon}}

  L'implémentation des fonctions appelées est donnée dans les sections traitant de ce que font ces fonctions (fonction \emph{listen} $\rightarrow$ communication, fonction \emph{closestObstacleDirection} $\rightarrow$ évitement d'obstacles, \ldots) à l'exception de \emph{checkGoalReached}, qui détecte de nouvelles sources et qui est présentée ci-dessous.
\begin{lstlisting}[caption=fonction doCommon]
function doCommon()
  local obstacleProximity, obstacleDirection,
        onSource, foundSource, backHome, gotSource,
        emerProx, emerDir

  odometry()
  onSource, foundSource, backHome = checkGoalReached()
  gotSource = listen()
  shortObstaclesTable = updateObstaclesTable("short_range",
                                             shortObstaclesTable)
  obstacleProximity, obstacleDirection
  =closestObstacleDirection(shortObstaclesTable)

  battery=battery-BATT_BY_STEP
  backForBattery = backForBattery
                   or battery-batterySecurity
                              *BATT_BY_STEP
                              *math.sqrt(posX^2+posY^2)
                              /BASE_SPEED<10

  emerProx, emerDir=readProxSensor()
  if battery==0 then
    BASE_SPEED=0
    logerr("batt empty")
  end
  if currentStep%5000==0 then
    log(travels)
  end
  return obstacleProximity, obstacleDirection,
         onSource, foundSource, backHome,
         gotSource, emerProx, emerDir
end
\end{lstlisting}

\subsection{Détection de nouvelle sources et du nid}

\begin{lstlisting}[caption=fonction checkGoalReached]
function checkGoalReached()
  local foundSource, onSource, backHome=false,false,false
  local insideBlack, seeBlack = floorIsBlack()
  if seeBlack and math.sqrt((posX)^2+(posY)^2)>=90 then
    if insideBlack and sourceIsOriginal(posX,posY, ressources) then
      ressources[#ressources+1]={posX,posY,score=.5}
      --store source. Initial quality index = 1/2
      foundSource=true
    end
    onSource=true
  elseif seeBlack and math.sqrt((posX)^2+(posY)^2)<=70 then
    if goalX==0 and goalY==0 then
      backHome=true
    end
    if backForBattery then
      batterySecurity=updateBattCoeff(battery,batterySecurity)
      backForBattery=false
    end
    battery=100
  end
  return onSource, foundSource, backHome
end
\end{lstlisting}

\begin{lstlisting}[caption=Détection de la couleur du sol]
function floorIsBlack()
  local insideBlack = true
  --will tell if robot is fully inside a source or the nest
  local seeBlack = false
  --will tell if robot is touching a source or the nest
  local clr,i
  for i=1,8 do
    clr = robot.base_ground[i].value
    seeBlack = seeBlack or clr== 0
    insideBlack = insideBlack and clr == 0
  end
  return insideBlack, seeBlack
end
\end{lstlisting}


\begin{lstlisting}[caption=Vérifier l'originalité de la source]
function sourceIsOriginal(x, y, rsc)
  local i=1
  local orgn=true
  while i<=#ressources and orgn do
    orgn=(math.sqrt((rsc[i][1]-x)^2 + (rsc[i][2]-y)^2)>ORGN_SRC_DST)
    --just check if it's far enough from sources you already know
    i=i+1
  end
  return orgn
end
\end{lstlisting}

\appsec{Implémentation du modèle de diffusion en Lua\label{appsec:gasLike}}

\begin{lstlisting}[caption=Déplacement \emph{gaslike}]
function gasLike(obstacleProximity, obstacleDirection)
  local goalAngle
  if obstacleProximity < 30
     and not(obstacleDirection<-PI/2 or obstacleDirection>PI/2)
     and not wasHit then
    wasHit = true --/!\Not local: allows footbot to remember
                  --if it's already trying to reach an angle
    newDirection = alpha+rebound(alpha,obstacleDirection)
    newDirection=setCoupure(newDirection)   --sets angle in [-PI,PI]
  end
  if wasHit then
    if abs(alpha-newDirection)<0.2 then --checks if angle is reached
      wasHit=false
    else
      goalAngle=newDirection-alpha
      goalAngle=setCoupure(goalAngle) --sets angle in [-PI,PI]
      getToGoal(goalAngle, EXPL_CONV)
      --EXPL_CONV is really high because we want to do sharp turns
    end
  else
    robot.wheels.set_velocity(BASE_SPEED,BASE_SPEED)
  end
end
\end{lstlisting}

\begin{lstlisting}[caption=Calcul de l'angle "réfléchi"]
function rebound(alpha, obstacleDirection)
  if obstacleDirection<=12 then   --obstacle is to the left
    newAngle = -2*(PI/2-obstacleDirection)
  else
    newAngle = 2*(PI/2-obstacleDirection)
  end
  newAngle=setCoupure(newAngle) --sets angle in [-PI,PI]
  return newAngle
end
\end{lstlisting}

\appsec{Implémentation du choix de ressource à exploiter en Lua\label{appsec:evalSource}}

\begin{lstlisting}[caption=fonction doMine]
function doMine(obstacleProximity, obstacleDirection,
                onSource, backHome, foundSource)
  if onSource then
    if goalX~=0 and goalY~=0 then
    --if we don't check for this then
    --we reevaluate at every step we're on the source
      evalSource(sourceId, battery)
    end
    goalX=0
    goalY=0
  elseif backHome then
    sourceId,goalX,goalY=chooseNewSource(ressources)
    travels=travels+1
  end
  if backForBattery then
    move(obstaclesTable, obstacleProximity, obstacleDirection,0,0)
  else
    obstaclesTable = updateObstaclesTable("long_range",obstaclesTable)
    move(obstaclesTable, obstacleProximity, obstacleDirection,goalX,goalY)
  end
end
\end{lstlisting}

\begin{lstlisting}[caption=Choix de la ressource à exploiter]
function chooseNewSource(rscList)
  local sourceChosen=false
  local pickSource
  while not sourceChosen do
    pickSource=robot.random.uniform_int(1,#rscList+1)
    sourceChosen=robot.random.uniform()<rscList[pickSource].score
  end
  local x=rscList[pickSource][1]
  local y=rscList[pickSource][2]
  return pickSource,x,y
  --return ressource index as well to make
  --ressource evaluation easier later
end
\end{lstlisting}

Cette implémentation permettrait en plus très facilement au robot de recommencer à explorer l'arène si les sources disponibles sont estimées peu rentables. En effet, il suffit d'ajouter un compteur à la boucle while et de repasser dans l'état \emph{explore} si ce compteur est atteint sans qu'une source ait été choisie. Cependant, il faudrait alors aussi permettre au footbot de changer d'état dans l'autre sens à d'autres occasions que seulement s'il trouve ou reçoit une nouvelle source, comme il a été évoqué dans la section \ref{sec:explore}.

\begin{lstlisting}[caption=Evaluation de la qualité de la source]
function evalSource(sourceId, battery)
  if battery>GOOD_MINE_BATT then
    ressources[sourceId].score=ressources[sourceId].score
                                +(1-ressources[sourceId].score)
                                  *battery/100
    --Ensures quality score goes up while staying <1
  else
    ressources[sourceId].score=ressources[sourceId].score
                                -ressources[sourceId].score
                                  *(100-battery)/100
    --Ensures quality score goes down while staying >0
  end
end
\end{lstlisting}



\end{subappendices}
